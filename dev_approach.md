# ExcelフローチャートAI変換：高精度Mermaid化ハイブリッドアプローチ【決定版】

## 1\. 目的

本ドキュメントは、Excel上で作成されたフローチャート（仕様書）を、AIを活用して高精度なMermaid記法のテキストデータに変換するための技術仕様を定義する。

**最大の課題:**
Excelのフローチャートは、図形（シェイプ）内に直接テキストが記述されているとは限らない。「図形の上に別途テキストボックスが配置されている」「枠線なしの図形がラベルとして使われている」といった複雑な構造が多用される。

**本アプローチの核心:**
単純なAIのOCR（画像認識）や単純なテキスト抽出に頼らない。

1.  **【Python】** Excelファイルから全シェイプの「座標情報」と「テキスト情報」を個別に全量抽出する。
2.  **【Python】** 座標情報に基づき、「どのテキストがどの図形に属するか」を強制的にマッピング（紐付け）する。
3.  **【AI】** AIには「構造（矢印）の認識」と「分岐ラベル（Yes/No）の認識」に集中させ、テキスト内容はPythonが生成した「指示書（JSON）」から参照させる。

これにより、AIのテキスト誤認識（OCRミス）をゼロにし、構造認識の精度を最大化する。

-----

## 2\. 全体プロセスフロー

1.  **[Python] データ抽出と座標マッピング**
      * 全シェイプの情報を抽出し、「図形（コンテナ）」と「テキスト」を座標で紐付ける。
2.  **[Python] JSON指示書の生成**
      * 紐付け結果を元に、「ID」と「正しいテキスト」の対応表（JSON）を生成する。
3.  **[Python] IDアンカー画像の生成**
      * 元のExcel画像のテキスト部分を、対応する「ID」に置き換えた参照用画像（アンカー画像）を生成する。
4.  **[AI] Mermaidコード生成**
      * 「IDアンカー画像」と「JSON指示書」をマルチモーダルAIに渡し、Mermaidコードを生成させる。
5.  **[Human] 検証と修正**
      * 生成されたMermaidをプレビューし、ロジック（特に分岐）を人間が最終確認・修正する。

-----

## 3\. ステップ1：[Python] データ抽出と座標マッピング（最重要）

**目的:** Excelファイルの複雑な構造を解析し、「どの図形が、どのテキストを持つか」を正確に特定する。

**使用ライブラリ(例):** `xlwings`, `json`

**開発要件:**

1.  **全シェイプ情報取得:**

      * シート上のすべての `shape` オブジェクトをループ処理し、以下の情報を含むリスト（`all_shapes`）を作成する。
          * `temp_id`: 一時的な識別子 (例: `temp_001`)
          * `text`: `shape.text_frame.characters.text` (空文字列の場合もそのまま取得)
          * `position`: `{ "top": shape.top, "left": shape.left, "width": shape.width, "height": shape.height }`
          * `shape_type`: `shape.auto_shape_type`

2.  **役割分類:**

      * `all_shapes` リストを、以下の2つのリストに分類する。
      * **`container_shapes` (コンテナ図形リスト):**
          * フローチャートのノード（箱）となる図形。
          * **条件(例):** `shape_type` が `msoShapeRectangle` (四角), `msoShapeFlowchartDecision` (ひし形), `msoShapeFlowchartTerminator` (開始/終了) など、テキストボックス (`msoTextBox`) やコネクタ (`msoConnectorStraight` など) **以外**のもの。
      * **`text_shapes` (テキスト図形リスト):**
          * テキストを持つ可能性のある図形。
          * **条件(例):** `text` が空文字列ではない、または `shape_type` が `msoTextBox` のもの。

3.  **座標マッピング処理 (核心ロジック):**

      * `container_shapes` (親) の各シェイプを基準にループする。
      * 親の座標範囲 (`parent_x1`, `parent_y1`, `parent_x2`, `parent_y2`) を取得する。
      * `text_shapes` (子) のリストを走査し、各シェイプの**中心座標** (`child_center_x`, `child_center_y`) を計算する。
      * **包含判定:** 子の中心座標が、親の座標範囲内に完全に含まれている (`parent_x1 < child_center_x < parent_x2` AND `parent_y1 < child_center_y < parent_y2`) かを判定する。
      * **紐付け:** 包含される `text_shape` を発見した場合、`container_shape['text'] = text_shape['text']` のように、親のテキスト情報を上書き（または設定）する。
      * **注意:** この時点で `container_shape` 自身がテキストを持っていた場合（最も単純なパターン）は、そのテキストを優先する（マッピング処理をスキップする）ロジックも有効。

-----

## 4\. ステップ2：[Python] JSON指示書とIDアンカー画像の生成

**目的:** ステップ1のマッピング結果に基づき、AIに渡す「指示書」と「参照画像」を生成する。

**使用ライブラリ(例):** `pyautogui` / `mss` (スクリーンショット), `Pillow (PIL)` (画像処理)

**開発要件:**

1.  **JSON指示書の生成 (`instructions.json`):**

      * ステップ1でテキストが紐付けられた `container_shapes` リストを元に、最終的なID (例: `node_001`, `node_002`...) を割り振る。
      * AIへの指示書となるJSONファイルを生成する。
      * **JSON出力例:**
        ```json
        [
          {
            "id": "node_001",
            "text": "受注処理開始",
            "shape_type": "msoShapeFlowchartTerminator",
            "position": { "top": 50, "left": 100, ... }
          },
          {
            "id": "node_002",
            "text": "在庫確認",
            "shape_type": "msoShapeRectangle",
            "position": { "top": 120, "left": 100, ... }
          },
          {
            "id": "node_003",
            "text": "在庫あり？",
            "shape_type": "msoShapeFlowchartDecision",
            "position": { "top": 190, "left": 100, ... }
          }
        ]
        ```

2.  **IDアンカー画像の生成 (`anchor_image.png`):**

      * 対象のExcelフローチャート領域のスクリーンショットを取得する。
      * `instructions.json` の各シェイプ情報をループ処理する。
      * 各シェイプの `position` 情報に基づき、スクリーンショット上の該当領域を**背景色などで塗りつぶす（マスキング）**。
      * マスキングした領域の中心に、対応する `id` (例: `node_001`) を読みやすいフォントで**描画する**。
      * **重要:** コネクタ（矢印）や、どのコンテナにもマッピングされなかったテキスト（矢印のラベル "Yes"/"No" など）は、マスキングや描画の対象とせず、**元の画像（スクリーンショット）のまま残す**。
      * 最終的な「IDアンカー画像」をファイルとして保存する。

-----

## 5\. ステップ3：[AI] Mermaidコード生成（プロンプト例）

**目的:** 「構造（IDアンカー画像）」と「テキスト（JSON指示書）」をAIに渡し、最終的なMermaidコードを生成させる。

  * **入力:**
    1.  `anchor_image.png` (ステップ2で生成)
    2.  `instructions.json` の内容 (ステップ2で生成)
  * **プロンプト例（フル）:**

<!-- end list -->

````text
あなたは、提供された画像とJSONデータからMermaidフローチャートを生成するシステムアーキテクトです。

以下の2つの情報を提供します。

【情報1：フローチャートの構造画像（ID付き）】
[ここに「IDアンカー画像」をアップロード]

* この画像は、図形の「つながり（矢印）」と「配置」を示しています。
* 各図形には `node_XXX` というIDが振られています。
* あなたのタスクは、この画像から「IDとIDのつながり（矢印）」と「矢印に付随する分岐ラベル（Yes/Noなど）」を正確に読み取ることです。

【情報2：図形の詳細データ（JSON）】
```json
[
  {
    "id": "node_001",
    "text": "受注処理開始",
    "shape_type": "msoShapeFlowchartTerminator"
  },
  {
    "id": "node_002",
    "text": "在庫確認",
    "shape_type": "msoShapeRectangle"
  },
  {
    "id": "node_003",
    "text": "在庫あり？",
    "shape_type": "msoShapeFlowchartDecision"
  }
  // ... 他のノードデータ ...
]
````

  * これは、画像内の各IDに対応する「正式なテキスト」と「図形の種類」のリストです。

【タスク】

1.  【情報1】の画像の「ID間のつながり」を視覚的に解析してください。
2.  【情報1】の画像の矢印の近くにある「分岐ラベル（"Yes", "No", "OK", "NG"など）」を読み取ってください。これらは【情報2】のJSONには含まれていません。
3.  【情報2】のJSONを使い、各IDを「正式なテキスト」と「図形の種類」にマッピングしてください。
4.  この情報を組み合わせて、完全なMermaid記法（`graph TD`）のコードを生成してください。

【Mermaid生成ルール】

  * **グラフ方向:** 常に `graph TD` （上から下）を使用します。
  * **ノード定義 (必須):**
      * `id["テキスト"]` (標準の四角形: msoShapeRectangle など)
      * `id{"テキスト"}` (ひし形: msoShapeFlowchartDecision)
      * `id(["テキスト"])` (角丸四角形: msoShapeFlowchartTerminator)
      * ※ 【情報2】の `shape_type` を参考に、Mermaidの適切な括弧（`[]`, `{}`, `()`）を使い分けてください。
  * **つながり:**
      * `id1 --> id2` (標準の矢印)
  * **分岐のラベル (最重要):**
      * ひし形（`node_003`など）からの矢印には、【情報1】の画像から読み取った分岐ラベルを必ず付与してください。
      * **書式:** `id1 -->|"ラベル"| id2`
      * **例:** `node_003 -->|"Yes"| node_004`
      * **例:** `node_003 -->|"No"| node_005`

生成したMermaidコードのみを出力してください。

---

## 6. ステップ4：[Human] 検証と修正プロセス

**目的:** AIの生成したロジック（特に分岐）が、元のExcelの意図と100%一致しているか最終確認する。

**確認ツール:** Mermaid Live Editor, VSCodeのMarkdownプレビューなど、Mermaidを即時プレビューできる環境。

**確認の優先順位と修正指示:**

1.  **最優先：分岐ロジックの確認**
    * **確認点:** ひし形（Decision）から出る矢印のラベル（"Yes", "No"など）は正しいか？ ラベルが適用される矢印の向き（`id --> id`）は正しいか？
    * **背景:** AIは矢印に付随する小さなテキストの認識・紐付けを最も間違えやすいため、最重要確認ポイントとなる。
    * **修正指示（AIへのフィードバック例）:**
        * 「`node_003` から `node_005` への矢印のラベルが "NG" になっていますが、正しくは "No" です。Mermaidコードを修正してください。」
        * 「`node_003` からの "Yes" の矢印は `node_004` ではなく `node_006` に接続してください。」

2.  **次点：接続（矢印）の欠落・間違い**
    * **確認点:** プレビューした図と元のExcelを見比べ、矢印が抜けている箇所はないか？ 矢印の向きが逆、または不要な矢印が生成されていないか？
    * **修正指示（例）:**
        * 「`node_007` から `node_001` へ戻る矢印が抜けています。追加してください。」

3.  **軽微：ノード定義の確認**
    * **確認点:** ノードの形状（四角、ひし形）は適切か？（このアプローチでは、JSONで指定しているため、ほぼ間違いないはず）
    * **修正指示（例）:**
        * 「`node_001` は開始ノードなので、`["テキスト"]` ではなく `(["テキスト"])` に修正してください。」

このハイブリッドアプローチにより、Excelの複雑なファイル構造に対応しつつ、AIの能力を最大限に引き出すことが可能となります。
